<!DOCTYPE html>
<html lang="zh-CN">

  
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  
  
  <title>Scala笔记 | shaohua&#39;s blog</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="大数据,Scala,">
  

  <script type="text/javascript">
	$(document).ready(function() {
	    //为超链接加上target='_blank'属性
		$('a[href^="http"]').each(function() {
			$(this).attr('target', '_blank');
		});
	});
  </script>

  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  <link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">

  <script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>

  

  
    <link href="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.css" rel="stylesheet">
    <script src="https://cdn.bootcss.com/aplayer/1.10.1/APlayer.min.js" async></script>
  

  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  

</head>

  <body>

    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">Fenghuayangyi</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a href="/" target="_self">
              主页
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a href="/archives/" target="_self">
              归档
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a href="/categories/" target="_self">
              分类
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a href="/tags/" target="_self">
              标签
            </a>
          
        </li>
      
        <li class="nav-item" data-path>
          
            <a href="javascript:void(0);" v-else>抓到我</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a href="https://github.com/fenghuayangyi" target="_blank">
                    Github
                  </a>
                </li>
              
                <li>
                  <a href="https://blog.csdn.net/u011295626" target="_blank">
                    CSDN
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>Scala笔记</span>
  </h1>
  <div class="article-top-meta">
    <span>
      发布 : 
      2019-10-16
    </span>
    
      <span>
        分类 : 
          <a href="/categories/大数据/">
            大数据
          </a>
      </span>
    
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <h1 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h1><p>静态编译的函数式语言。</p>
<h2 id="1-基本语法注意规范"><a href="#1-基本语法注意规范" class="headerlink" title="1. 基本语法注意规范"></a>1. 基本语法注意规范</h2><ul>
<li><p>大小写敏感</p>
</li>
<li><p>类名 单词首字母大写</p>
</li>
<li><p>方法名的命名规则类似的 camel 命名规则</p>
</li>
<li><p>程序文件名和对象名称完全匹配</p>
</li>
<li><p>scala入口 def main(args: Array[String])</p>
</li>
<li><p><strong>一些不了解的关键字</strong>：implicit，lazy，sealed，object，trait，yield</p>
</li>
<li><p><strong>一些不熟悉的数据类型</strong>：Unit，Nothing，Any，AnyRef</p>
<p>Unit等价于 void 只有一个实例，写成（）</p>
<p>Nothing类型是任何其他类型的子类型</p>
<p>Any 是所有其他类的超类</p>
<p>AnyRef是所有引用类（reference class）的基类。</p>
<p>PS:scala中所有的数据类型都是对象。</p>
</li>
<li><p>val 修饰不可变变量相当于final修饰，var修饰可变变量</p>
</li>
<li><p>访问修饰符</p>
<p>private（类内访问），protected（子类），public。</p>
<p>默认情况下，Scala 对象的访问级别都是 public。</p>
<p>Scala 中的 private 限定符，比 Java 更严格，在嵌套类情况下，外层类甚至不能访问被嵌套类的私有成员。</p>
</li>
<li><p>​</p>
</li>
<li><p>，</p>
</li>
</ul>
<h2 id="2-循环类型"><a href="#2-循环类型" class="headerlink" title="2. 循环类型"></a>2. 循环类型</h2><p> while, do…while, for中只有for和java略有区别。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">for( a &lt;- 1 to 10)&#123;</span><br><span class="line">	println( &quot;Value of a: &quot; + a );</span><br><span class="line">&#125;</span><br><span class="line">1....10</span><br><span class="line">for( a &lt;- 1 to 10)&#123;</span><br><span class="line">	println( &quot;Value of a: &quot; + a );</span><br><span class="line">&#125;</span><br><span class="line">1....9</span><br><span class="line"></span><br><span class="line">--两层嵌套</span><br><span class="line">for( a &lt;- 1 to 3; b &lt;- 1 to 3)&#123;</span><br><span class="line">    println( &quot;Value of a: &quot; + a );</span><br><span class="line">    println( &quot;Value of b: &quot; + b );</span><br><span class="line">&#125;</span><br><span class="line">外层a  内层b</span><br><span class="line"></span><br><span class="line">-- 集合用法</span><br><span class="line">var a = 0;</span><br><span class="line">val numList = List(1,2,3,4,5,6,7,8,9);</span><br><span class="line">for( a &lt;- numList )&#123;</span><br><span class="line">	println( &quot;Value of a: &quot; + a );</span><br><span class="line">&#125;</span><br><span class="line">for 循环会迭代所有集合的元素。</span><br><span class="line"></span><br><span class="line">-- for 循环过滤 3以及大于等于8的</span><br><span class="line">for( a &lt;- numList</span><br><span class="line">	if a != 3; if a &lt; 8 )&#123;</span><br><span class="line">	println( &quot;Value of a: &quot; + a );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-- for 使用 yield 将for循环的返回值作为一个变量存储。</span><br><span class="line">var retVal = for&#123; a &lt;- numList </span><br><span class="line">	if a != 3; if a &lt; 8</span><br><span class="line">&#125;yield a</span><br><span class="line">for( a &lt;- retVal)&#123;</span><br><span class="line">	println( &quot;Value of a: &quot; + a );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-方法和函数"><a href="#3-方法和函数" class="headerlink" title="3. 方法和函数"></a>3. 方法和函数</h2><p>Scala 有方法与函数，二者在语义上的区别很小。Scala <strong>方法是类的一部分</strong>，而<strong>函数是一个对象可以赋值给一个变量</strong>。</p>
<p>总结一下就是—–在类中定义的函数即是方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Test&#123;</span><br><span class="line">  def m(x: Int) = x + 3 //方法</span><br><span class="line">  val f = (x: Int) =&gt; x + 3 //函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-1-方法调用"><a href="#3-1-方法调用" class="headerlink" title="3.1 方法调用"></a>3.1 方法调用</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">object Test &#123;</span><br><span class="line">   def main(args: Array[String]) &#123;</span><br><span class="line">        println( &quot;Returned Value : &quot; + addInt(5,7) );</span><br><span class="line">   &#125;</span><br><span class="line">   def addInt( a:Int, b:Int ) : Int = &#123;</span><br><span class="line">      var sum:Int = 0</span><br><span class="line">      sum = a + b</span><br><span class="line">      return sum</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-2-闭包"><a href="#3-2-闭包" class="headerlink" title="3.2 闭包"></a>3.2 闭包</h3><p><strong>闭包是一个函数</strong>，返回值依赖于<strong><em>声明在函数外部的一个或多个变量</em></strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//一般情况</span><br><span class="line">val multiplier = (i:Int) =&gt; i * 10</span><br><span class="line">//由变量 factor 定义在函数外面，</span><br><span class="line">var factor = 3  </span><br><span class="line">val multiplier = (i:Int) =&gt; i * factor</span><br><span class="line">/* 这样定义的函数变量 multiplier 成为一个&quot;闭包&quot;，因为它引用到函数外面定义的变量，定义这个函数的过程是将这个自由变量捕获而构成一个封闭的函数。*/</span><br></pre></td></tr></table></figure>
<h2 id="4-常用数据结构"><a href="#4-常用数据结构" class="headerlink" title="4. 常用数据结构"></a>4. 常用数据结构</h2><h3 id="4-1-字符串"><a href="#4-1-字符串" class="headerlink" title="4.1 字符串"></a>4.1 字符串</h3><p>常用的记一下，用的时候再查。</p>
<ul>
<li><p>字符串拼接。string1.concat(string2);</p>
</li>
<li><p>创建格式化字符串。使用 printf() 方法来格式化字符串并输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var floatVar = 12.456</span><br><span class="line">var intVar = 2000</span><br><span class="line">var stringVar = &quot;菜鸟教程!&quot;</span><br><span class="line">var fs = printf(&quot;浮点型变量为 &quot; +</span><br><span class="line">    &quot;%f, 整型变量为 %d, 字符串为 &quot; +</span><br><span class="line">    &quot; %s&quot;, floatVar, intVar, stringVar)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="4-2-数组"><a href="#4-2-数组" class="headerlink" title="4.2 数组"></a>4.2 数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var z:Array[String] = new Array[String](3)</span><br><span class="line">或</span><br><span class="line">var z = new Array[String](3)</span><br><span class="line"></span><br><span class="line">//多维数组</span><br><span class="line">var myMatrix = ofDim[Int](3,3)</span><br><span class="line"></span><br><span class="line">//创建区间数组</span><br><span class="line">var myList1 = range(10, 20, 2) --  10 - 18的偶数</span><br><span class="line">var myList2 = range(10,20) --   10 - 19</span><br><span class="line"></span><br><span class="line">// 查找数组中的最大元素</span><br><span class="line">var max = myList(0);</span><br><span class="line">for ( i &lt;- 1 to (myList.length - 1) ) &#123;</span><br><span class="line">	if (myList(i) &gt; max) max = myList(i);</span><br><span class="line">&#125;</span><br><span class="line">println(&quot;最大值为 &quot; + max);</span><br><span class="line"></span><br><span class="line">//合并数组</span><br><span class="line">var myList3 =  concat( myList1, myList2)</span><br></pre></td></tr></table></figure>
<h3 id="4-3-集合"><a href="#4-3-集合" class="headerlink" title="4.3 集合"></a>4.3 集合</h3><ul>
<li><p>使用(:+)和(+:)，向后向前追加元素到序列。</p>
</li>
<li><p>(+)元素到<strong>无先后次序的集合</strong>中。</p>
</li>
<li><p>用 - 移除元素</p>
</li>
<li><p>用 ++ 和 – 批量添加和移除元素</p>
</li>
<li><p>对于<strong>列表</strong>优先使用 :: 和 :::</p>
</li>
<li><p>改值操作 +=，++=，-=，–=</p>
</li>
<li><p>对于集合更倾向于 ++ 、&amp; 和 –</p>
</li>
<li><p>尽量不要使用 ++：，+=：，++=：</p>
<p>对于列表，可以使用+= 而不用:: 保持与其他集合操作的一致性，但有一个例外：</p>
<p>模式匹配（case h::t）不认+：操作符。</p>
</li>
</ul>
<h4 id="4-3-1-List"><a href="#4-3-1-List" class="headerlink" title="4.3.1 List"></a>4.3.1 List</h4><p>元素以线性方式存储，集合中可以存放重复对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val x = List(1,2,3,4)</span><br><span class="line">::添加元素</span><br><span class="line">:::链表拼接</span><br></pre></td></tr></table></figure>
<h4 id="4-3-2-Set"><a href="#4-3-2-Set" class="headerlink" title="4.3.2 Set"></a>4.3.2 Set</h4><p>集合中的对象不按特定的方式排序，并且没有重复对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val x = Set(1,3,5,7)</span><br><span class="line">+ 添加元素</span><br><span class="line">++ 集合拼接</span><br></pre></td></tr></table></figure>
<h4 id="4-3-3-Map"><a href="#4-3-3-Map" class="headerlink" title="4.3.3 Map"></a>4.3.3 Map</h4><p>它的每一个元素都包含一对键对象和值对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val x = Map(&quot;one&quot; -&gt; 1, &quot;two&quot; -&gt; 2, &quot;three&quot; -&gt; 3)</span><br></pre></td></tr></table></figure>
<h4 id="4-3-4-元组"><a href="#4-3-4-元组" class="headerlink" title="4.3.4 元组"></a>4.3.4 元组</h4><p>元组不可变，且是不同类型的值的集合</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val x = (10, &quot;Runoob&quot;)</span><br></pre></td></tr></table></figure>
<h4 id="4-3-5-迭代器"><a href="#4-3-5-迭代器" class="headerlink" title="4.3.5 迭代器"></a>4.3.5 迭代器</h4><p>迭代器不是一个容器，更确切的说是逐一访问容器内元素的方法。</p>
<h4 id="4-3-5-Option"><a href="#4-3-5-Option" class="headerlink" title="4.3.5 Option"></a>4.3.5 Option</h4><p>Option[T] 表示有可能包含值的容器，也可能不包含值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val x:Option[Int] = Some(5)</span><br></pre></td></tr></table></figure>
<p>Map类的get方法返回一个Option。如果对于一个给定的键没有对应的值，就会返回None, 如果有值，返回。</p>
<h2 id="5-类"><a href="#5-类" class="headerlink" title="5. 类"></a>5. 类</h2><p>Scala中的类不声明为public，一个Scala源文件中可以有多个类。</p>
<ul>
<li><p>构造器</p>
<p><strong>一个类如果没有显示定义主构造器则会自动拥有一个无参主构造器。</strong></p>
<p>scala 的 类中 有一个主构造器 和 多个 辅助构造器。</p>
<ul>
<li><p><strong>辅助构造器</strong></p>
<ol>
<li>辅助构造器的<strong>名称为this</strong>.</li>
<li>每一个辅助构造器都必须以一个先前已经定义好的其他辅助构造器或主构造器的<strong>调用开始</strong>。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Person&#123;</span><br><span class="line">    private var name = &quot;&quot;</span><br><span class="line">    private var age = 0</span><br><span class="line">    def this(name:String)&#123;//一个辅助构造器</span><br><span class="line">       this() //调用主构造器</span><br><span class="line">       this.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    def this(name:String, age:Int)&#123;//另一个辅助构造器</span><br><span class="line">       this(name) //调用上一个辅助构造器</span><br><span class="line">       this.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">三种不同的方式构建对象：</span><br><span class="line">val p1 = new Person //主构造器</span><br><span class="line">val p2 = new Person(&quot;Fred&quot;) //第一个辅助构造器</span><br><span class="line">val p3 = new Person(&quot;Fred&quot;,42) //第二个辅助主构造器</span><br></pre></td></tr></table></figure>
</li>
<li><p>主构造器</p>
<p>主构造器不以this方法定义，<strong>与类定义交织在一起</strong>。如果类名之后没有参数，则该类具备一个无参主构造器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Person(val name:String, val age:Int)&#123; //(...)中的内容就是主构造器的参数</span><br><span class="line">    println(&quot;constrcture&quot;)</span><br><span class="line">    def description = name + &quot; is&quot; + age + &quot; years old&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">主构造器会执行类定义中的所有语句</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="5-1-继承"><a href="#5-1-继承" class="headerlink" title="5.1 继承"></a>5.1 继承</h3><p>Scala继承一个基类跟Java很相似, 但我们需要注意以下几点：</p>
<ul>
<li><strong>在子类中重写超类的抽象方法时，你不需要使用override关键字。</strong></li>
<li><strong>重写一个非抽象方法必须使用override修饰符。</strong></li>
<li><strong>只有主构造函数才可以往基类的构造函数里写参数。</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">	Scala 使用 extends 关键字来继承一个类。实例中 Location 类继承了 Point 类。Point 称为父类(基类)，Location 称为子类。</span><br><span class="line">	override val xc 为重写了父类的字段。</span><br><span class="line">	继承会继承父类的所有属性和方法，Scala 只允许继承一个父类。</span><br><span class="line"></span><br><span class="line">class Point(xc: Int, yc: Int) &#123;</span><br><span class="line">   var x: Int = xc</span><br><span class="line">   var y: Int = yc</span><br><span class="line"></span><br><span class="line">   def move(dx: Int, dy: Int) &#123;</span><br><span class="line">      x = x + dx</span><br><span class="line">      y = y + dy</span><br><span class="line">      println (&quot;x 的坐标点: &quot; + x);</span><br><span class="line">      println (&quot;y 的坐标点: &quot; + y);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Location(override val xc: Int, override val yc: Int,</span><br><span class="line">   val zc :Int) extends Point(xc, yc)&#123;</span><br><span class="line">   var z: Int = zc</span><br><span class="line"></span><br><span class="line">   def move(dx: Int, dy: Int, dz: Int) &#123;</span><br><span class="line">      x = x + dx</span><br><span class="line">      y = y + dy</span><br><span class="line">      z = z + dz</span><br><span class="line">      println (&quot;x 的坐标点 : &quot; + x);</span><br><span class="line">      println (&quot;y 的坐标点 : &quot; + y);</span><br><span class="line">      println (&quot;z 的坐标点 : &quot; + z);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-2-单例对象"><a href="#5-2-单例对象" class="headerlink" title="5.2 单例对象"></a>5.2 单例对象</h3><p>在 Scala 中，是没有 static 。使用<strong>关键字 object</strong> 提供单例模式的实现方法。</p>
<p>Scala 中<strong>使用单例模式时</strong>，除了定义的类之外，还要定义一个<strong>同名的 object 对象</strong>（伴生对象），它和类的区别是，object对象不能带参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">文件名：Marker.scala</span><br><span class="line"></span><br><span class="line">class Marker private(val color:String) &#123;</span><br><span class="line"></span><br><span class="line">  println(&quot;创建&quot; + this)</span><br><span class="line">  </span><br><span class="line">  override def toString(): String = &quot;颜色标记：&quot;+ color</span><br><span class="line">  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 伴生对象，与类名字相同，可以访问类的私有属性和方法</span><br><span class="line">object Marker&#123;</span><br><span class="line">  </span><br><span class="line">    private val markers: Map[String, Marker] = Map(</span><br><span class="line">      &quot;red&quot; -&gt; new Marker(&quot;red&quot;),</span><br><span class="line">      &quot;blue&quot; -&gt; new Marker(&quot;blue&quot;),</span><br><span class="line">      &quot;green&quot; -&gt; new Marker(&quot;green&quot;)</span><br><span class="line">    )</span><br><span class="line">    </span><br><span class="line">    def apply(color:String) = &#123;</span><br><span class="line">      if(markers.contains(color)) markers(color) else null</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    </span><br><span class="line">    def getMarker(color:String) = &#123; </span><br><span class="line">      if(markers.contains(color)) markers(color) else null</span><br><span class="line">    &#125;</span><br><span class="line">    def main(args: Array[String]) &#123; </span><br><span class="line">        println(Marker(&quot;red&quot;))  </span><br><span class="line">        // 单例函数调用，省略了.(点)符号  </span><br><span class="line">        println(Marker getMarker &quot;blue&quot;)  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ scalac Marker.scala </span><br><span class="line">$ scala Marker</span><br></pre></td></tr></table></figure>
<h3 id="5-3-密封类"><a href="#5-3-密封类" class="headerlink" title="5.3 密封类"></a>5.3 密封类</h3><p>sealed 修饰的类，为密封类。</p>
<p>密封类的所有子类都必须在与该密封类<strong>相同的文件中定义</strong>。</p>
<p>如果一个类是密封的，在编译期所有的子类就是可知的，因此编译器可以检查模式语句的完整性。</p>
<h2 id="6-更好的switch"><a href="#6-更好的switch" class="headerlink" title="6. 更好的switch"></a>6. 更好的switch</h2><p>—match</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">def matchTest(x: Char): String = x match &#123;</span><br><span class="line">    case &apos;+&apos; =&gt; 1</span><br><span class="line">    case &apos;-&apos; =&gt; -1</span><br><span class="line">    case _ =&gt; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//简化代码</span><br><span class="line">var charac = x match&#123;</span><br><span class="line">    case &apos;+&apos; =&gt; 1</span><br><span class="line">    case &apos;-&apos; =&gt; -1</span><br><span class="line">    case _ =&gt; 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//守卫</span><br><span class="line">可以匹配符合定义的条件</span><br><span class="line">var charac = x match&#123;</span><br><span class="line">    case &apos;+&apos; =&gt; 1</span><br><span class="line">    case &apos;-&apos; =&gt; -1</span><br><span class="line">    case _ if Character.isDigit(ch) =&gt; Character.isDigit(ch, 10)</span><br><span class="line">    case _ =&gt; 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="7-高阶函数"><a href="#7-高阶函数" class="headerlink" title="7. 高阶函数"></a>7. 高阶函数</h2><p><strong>接收函数参数的函数称为高阶函数</strong>。</p>
<ul>
<li><p>带函数参数的函数</p>
<p>def valueAtOneQuarter(f: (Double)=&gt;Double) = f(0.25)</p>
<p>这里的参数是任何接受Double并返回Double的函数。</p>
<p>例如： valueAtOneQuarter（ceil _）//1.0</p>
<p>   valueAtOneQuarter（sqrt _） //0.5</p>
<p>​</p>
<p>高阶函数产出一个函数：</p>
<p>def mulBy(factor: Double) = (x: Double) =&gt; factor * x</p>
<p>val quintuple = mulBy(5)   //这里返回给quintuple的是一个能接受Double参数的函数</p>
<p>quintuple(20) //调用函数</p>
</li>
<li><p>参数类型推断</p>
<p>将一个匿名函数传递给一个函数</p>
<p>def valueAtOneQuarter(（x : Double） =&gt; 3 * x)</p>
<p>简写1：def valueAtOneQuarter(（x） =&gt; 3 * x)</p>
<p>简写2：def valueAtOneQuarter(x =&gt; 3 * x) //一个参数的情况</p>
<p>简写2：def valueAtOneQuarter(3 * _) //一个参数的情况</p>
<p>PS:这种写法仅在参数类型已知的情况下。</p>
<p>val fun = 3 * _ //错误</p>
<p>val fun = 3 * (_: Double)  //正确</p>
</li>
<li><p>柯里化</p>
<p>将原来接受两个参数的函数 变成 新的接受一个参数的函数的过程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def mul(x:Int, y:Int) = x*y</span><br><span class="line"></span><br><span class="line">以下函数接受一个参数，生成另一个接受单个参数的函数</span><br><span class="line">def mulOneAtTime(x:Int) = (y:Int)=&gt;x*y</span><br><span class="line">调用： mulOneAtTime(6)(7)</span><br><span class="line"> mulOneAtTime(6)返回结果是函数 (y:Int)=&gt;6*y，然后应用到7得到42</span><br><span class="line"> </span><br><span class="line"> scala支持简写：****这样的函数成为柯里化</span><br><span class="line"> def mulOneAtTime(x:Int)(y:Int)=&gt;x*y</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">函数式编程实现 立方和，平方和以及阶乘和</span><br><span class="line"></span><br><span class="line">//一个高阶函数实现相同的求和逻辑</span><br><span class="line">def sum(f:Int =&gt; Int)(a:Int, b:Int):Int = if(a&gt;b) 0 else f(a)+sum(f)(a+1,b)</span><br><span class="line"></span><br><span class="line">//柯里化后的sum函数</span><br><span class="line">def sum(f:Int =&gt; Int)(a:Int)(b:Int):Int = if(a&gt;b) 0 else f(a)+sum(f)(a+1)(b)</span><br><span class="line"></span><br><span class="line">//定义复杂函数 阶乘</span><br><span class="line">def fact(n:Int):Int = if（n==0）1 else n*fact(n-1)</span><br><span class="line"></span><br><span class="line">//直接调用高阶函数实现1-10 立方和，平方和以及阶乘和</span><br><span class="line">sum(x =&gt; x*x*x)(1,10)</span><br><span class="line">sum(x =&gt; x*x)(1,10)</span><br><span class="line">sum(x =&gt; fact)(1,10)</span><br><span class="line"></span><br><span class="line">//柯里化后调用</span><br><span class="line">sum(x =&gt; x*x*x)(1)(10)</span><br><span class="line">sum(x =&gt; x*x)(1)(10)</span><br><span class="line">sum(x =&gt; fact)(1)(10)</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ul>
<h2 id="8-隐式转换和隐式参数"><a href="#8-隐式转换和隐式参数" class="headerlink" title="8. 隐式转换和隐式参数"></a>8. 隐式转换和隐式参数</h2><ul>
<li>隐式转换用于类型之间的转换</li>
<li>隐式参数列表会要求指定类型的对象。</li>
<li>如果隐式参数是一个单参数的函数，他同时也会被当作隐式转换使用。</li>
</ul>
<h3 id="8-1隐式转换"><a href="#8-1隐式转换" class="headerlink" title="8.1隐式转换"></a>8.1隐式转换</h3><p>所谓隐式转换是指以<strong>implicit关键字声明</strong>的带有单个参数的函数。</p>
<p>这样的函数将会被<strong>自动应用</strong>，<strong>将值的一种类型转换为另一种类型</strong>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implicit def int2Fraction(n:Int) = Fraction(n,1)</span><br><span class="line">var result = 3 * Fraction(4,5) //这里将调用int2Fraction</span><br><span class="line">这里的隐式转换本质是 此函数 函数名不变，但是执行的行为是转换过的行为。</span><br></pre></td></tr></table></figure>
<h2 id="9-Spark-Scala-算子"><a href="#9-Spark-Scala-算子" class="headerlink" title="9. Spark-Scala 算子"></a>9. Spark-Scala 算子</h2><p>主要将算子分为两大类：Transformations算子 和 Action算子</p>
<p>Transformations算子：map, flatmap, filter, reduceByKey和sortBy, sortByKey, sample抽样, join, leftOuterJoin,  rightOutJoin, union, intersection, subtract, mapPartitions, distinct(map+reduceByKey+map), cogroup, mapPartitionsWithIndex, repartition, zip&amp;zipwithindex   大致16个</p>
<p>Action算子：count, collect, first, take, foreachPartition, reduce&amp;countByKey&amp;countByValue 大致6个</p>
<h3 id="9-1-Transformations算子"><a href="#9-1-Transformations算子" class="headerlink" title="9.1 Transformations算子"></a>9.1 Transformations算子</h3><p>Transformation 操作是延迟计算的，也就是说从一个RDD 转换生成另一个 RDD 的转换操作不是马上执行，需要等到有 Action 操作的时候才会真正触发运算。</p>
<h4 id="9-1-1-map-一对一"><a href="#9-1-1-map-一对一" class="headerlink" title="9.1.1 map 一对一"></a>9.1.1 map 一对一</h4><ul>
<li><p>特点：一进一出</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines.map(_+&quot;#&quot;).foreach(println)</span><br></pre></td></tr></table></figure>
<p>mapValues</p>
</li>
<li><p>该操作只改动value, 不改变key</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>​</p>
</li>
</ul>
<h4 id="9-1-2-flatMap-一对多"><a href="#9-1-2-flatMap-一对多" class="headerlink" title="9.1.2 flatMap 一对多"></a>9.1.2 flatMap 一对多</h4><ul>
<li><p>特点：一进多出， 比如按空格split</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lines.flatMap(_.split(&quot; &quot;)).foreach(println)</span><br></pre></td></tr></table></figure>
<p>flatMapValues</p>
</li>
<li><p>只操作value, 不改变key</p>
</li>
</ul>
<h4 id="9-1-3-filter过滤"><a href="#9-1-3-filter过滤" class="headerlink" title="9.1.3 filter过滤"></a>9.1.3 filter过滤</h4><ul>
<li><p>特点：一进，符合定义规则的出去</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val rdd1 = lines.flatMap(_.split(&quot; &quot;))</span><br><span class="line">rdd1.filter(&quot;hello&quot;.equals(_)).foreach(println)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-4-reduceByKey和sortBy"><a href="#9-1-4-reduceByKey和sortBy" class="headerlink" title="9.1.4 reduceByKey和sortBy"></a>9.1.4 reduceByKey和sortBy</h4><ul>
<li><p>reduceByKey相当于MR的reduce过程，将相同的key聚合，并执行逻辑。聚合的时候是要对RDD排序的，默认是升序的，如果要想实现降序排列就要用到sortBy了。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">val words = lines.flatMap(_.split(&quot; &quot;))</span><br><span class="line">val pairWords = words.map((_,1))</span><br><span class="line">val result = pairWords.reduceByKey(_+_)</span><br><span class="line">result.sortBy(_._2,false).foreach(println) //降序</span><br><span class="line">result.sortBy(_._2).foreach(println) //升序</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-5-sortByKey"><a href="#9-1-5-sortByKey" class="headerlink" title="9.1.5 sortByKey"></a>9.1.5 sortByKey</h4><ul>
<li><p>使用sortByKey实现sortBy的功能：“hello world”—&gt;“hello” “world”—&gt;（hello，1） （world，1）</p>
<p>关键的时候来了，利用tuple的swap反转，（hello 1）—&gt;（1，hello）</p>
<p>使用sortByKey来进行排序，然后再利用一次反转</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">val words = lines.flatMap(_.split(&quot; &quot;))</span><br><span class="line">val pairWords = words.map((_,1))</span><br><span class="line">val result = pairWords.reduceByKey(_+_)</span><br><span class="line">val transRDD = result.map(_.swap) //反转key value，string，int  变  int，string</span><br><span class="line">val r = transRDD.sortByKey(false) //降序</span><br><span class="line">r.map(_.swap).foreach(println)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-6-sample-抽样"><a href="#9-1-6-sample-抽样" class="headerlink" title="9.1.6 sample 抽样"></a>9.1.6 sample 抽样</h4><ul>
<li><p>抽样算子</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* sample算子抽样</span><br><span class="line">* true:抽出来一个，完事再放回去，再继续抽。即又放回抽样</span><br><span class="line">* 0.1:抽样的比例 10%</span><br><span class="line">* 100L:指定种子，抽到的数据不管运行多少次都一样</span><br><span class="line">*/</span><br><span class="line">val result = lines.sample(true,0.1,100L)</span><br><span class="line">result.foreach(println)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-6-join"><a href="#9-1-6-join" class="headerlink" title="9.1.6 join"></a>9.1.6 join</h4><ul>
<li><p>等值连接 (k,v) (k,w)—&gt;(k,(v,w))，k相同的join在一起</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result = rdd1.join(rdd2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>左外连接 leftOuterJoin  以左为主，没有的用None占位</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result = rdd1.leftOuterJoin(rdd2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>右外连接rightOuterJoin  以右为主，没有的用None占位</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result = rdd1.rightOuterJoin(rdd2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-7-union"><a href="#9-1-7-union" class="headerlink" title="9.1.7 union"></a>9.1.7 union</h4><ul>
<li><p>合并两个数据集，类型要一致</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result = rdd1.union(rdd2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-8-intersection"><a href="#9-1-8-intersection" class="headerlink" title="9.1.8 intersection"></a>9.1.8 intersection</h4><ul>
<li><p>取两个RDD的交集</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result = rdd1.intersection(rdd2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-9-subtract"><a href="#9-1-9-subtract" class="headerlink" title="9.1.9 subtract"></a>9.1.9 subtract</h4><ul>
<li><p>取差集</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result = rdd1.subtract(rdd2)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-10-mapPartitions"><a href="#9-1-10-mapPartitions" class="headerlink" title="9.1.10 mapPartitions"></a>9.1.10 mapPartitions</h4><ul>
<li><p>和map类似，遍历的单位是每个partition上的数据</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">val result = rdd1.mapPartitions(iter=&gt;&#123;</span><br><span class="line">	val listBuffer = new ListBuffer[String]()</span><br><span class="line">	println(&quot;打开&quot;)</span><br><span class="line">	while (iter.hasNext)&#123;</span><br><span class="line">		val s = iter.next()</span><br><span class="line">		println(&quot;插入 &quot;+s)</span><br><span class="line">		listBuffer.append(s+&quot; #&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	println(&quot;关闭&quot;)</span><br><span class="line">	listBuffer.iterator</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-11-distinct"><a href="#9-1-11-distinct" class="headerlink" title="9.1.11 distinct"></a>9.1.11 distinct</h4><ul>
<li><p>去重算子（先按照partition去重，总体去重） 流程大致相当于 ，map+reduceByKey+map</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val rdd1 = sc.makeRDD(Array[String](&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;a&quot;, &quot;d&quot;, &quot;e&quot;, &quot;a&quot;, &quot;b&quot;))</span><br><span class="line">val result = rdd1.distinct()</span><br><span class="line">val result = rdd1.map((_,1)).reduceByKey(_+_).map(_._1)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-12-cogroup"><a href="#9-1-12-cogroup" class="headerlink" title="9.1.12 cogroup"></a>9.1.12 cogroup</h4><ul>
<li><p>对多个RDD中的KV元素，每个RDD中相同key中的元素分别聚合成一个集合CompactBuffer。</p>
<p>然后将不同RDD的相同key的CompactBuffer（类似链表）组成新的values(类似于集合数组)</p>
<p>与reduceByKey不同的是针对两个RDD中相同的key的元素进行合并。(可以运行下示例就能清楚的理解)</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">val result = rdd1.cogroup(rdd2,rdd3) //三个rdd都是 key value形式数据</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">val DBName=Array(</span><br><span class="line">  Tuple2(1,&quot;Spark&quot;),</span><br><span class="line">  Tuple2(2,&quot;Hadoop&quot;),</span><br><span class="line">  Tuple2(3,&quot;Kylin&quot;),</span><br><span class="line">  Tuple2(4,&quot;Flink&quot;)</span><br><span class="line">)</span><br><span class="line">val numType=Array(</span><br><span class="line">  Tuple2(1,&quot;String&quot;),</span><br><span class="line">  Tuple2(2,&quot;int&quot;),</span><br><span class="line">  Tuple2(3,&quot;byte&quot;),</span><br><span class="line">  Tuple2(4,&quot;bollean&quot;),</span><br><span class="line">  Tuple2(5,&quot;float&quot;),</span><br><span class="line">  Tuple2(1,&quot;34&quot;),</span><br><span class="line">  Tuple2(1,&quot;45&quot;),</span><br><span class="line">  Tuple2(2,&quot;47&quot;),</span><br><span class="line">  Tuple2(3,&quot;75&quot;),</span><br><span class="line">  Tuple2(4,&quot;95&quot;),</span><br><span class="line">  Tuple2(5,&quot;16&quot;),</span><br><span class="line">  Tuple2(1,&quot;85&quot;)</span><br><span class="line">)</span><br><span class="line">val names=sc.parallelize(DBName)</span><br><span class="line">val types=sc.parallelize(numType)</span><br><span class="line">val nameAndType=names.cogroup(types)</span><br><span class="line">nameAndType.collect.foreach(println)</span><br></pre></td></tr></table></figure>
</li>
<li><p>​</p>
</li>
</ul>
<h4 id="9-1-13-mapPartitionsWithIndex"><a href="#9-1-13-mapPartitionsWithIndex" class="headerlink" title="9.1.13 mapPartitionsWithIndex"></a>9.1.13 mapPartitionsWithIndex</h4><ul>
<li><p>index 分区号，iter 分区号下的数据</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val rdd2 = rdd1.mapPartitionsWithIndex((index,iter)=&gt;&#123;</span><br><span class="line">    val list = new ListBuffer[String]()</span><br><span class="line">    while(iter.hasNext)&#123;</span><br><span class="line">        val elem = iter.next()</span><br><span class="line">        list += (s&quot;rdd1 partition = $index, value = $elem&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    list.iterator</span><br><span class="line">&#125;)</span><br><span class="line">rdd2.foreach(println)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-14-repartition-和-coalesce"><a href="#9-1-14-repartition-和-coalesce" class="headerlink" title="9.1.14 repartition 和 coalesce"></a>9.1.14 repartition 和 coalesce</h4><p>coalesce()：对RDD的分区进行再在分区，（用于分区数据分布不均匀的情况，利用HashPartitioner函数将数据重新分区）</p>
<p>reparation：与coalesce功能一样，它只是coalesce中shuffle设置为true的简易实现。（数据不经过shuffle是无法将RDD的分区变多的）</p>
<ul>
<li><p>可以增多或者减少分区。宽依赖算子，会产生shuffle;</p>
</li>
<li><p>区别于coalesce，coalesce同样可能增加、减少分区。</p>
</li>
<li><p>但是coalesce是窄依赖算子，默认无shuffle，可通过设置true来开启。</p>
</li>
<li><p>可以变相的理解为：repartition常用于增多分区，coalesce常用于减少分区。</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">val rdd3 = rdd2.repartition(3)</span><br><span class="line">rdd3.mapPartitionsWithIndex((index, iter) =&gt; &#123;</span><br><span class="line">	val list = new ListBuffer[String]()</span><br><span class="line">	while (iter.hasNext) &#123;</span><br><span class="line">		val one = iter.next()</span><br><span class="line">		list += (s&quot;rdd1 partition = $index ,value = $one&quot;)</span><br><span class="line">	&#125;</span><br><span class="line">	list.iterator</span><br><span class="line">&#125;).foreach(println)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-15-zip-amp-zipwithindex"><a href="#9-1-15-zip-amp-zipwithindex" class="headerlink" title="9.1.15 zip&amp;zipwithindex"></a>9.1.15 zip&amp;zipwithindex</h4><ul>
<li><p>zip:两个RDD可以通过zip压缩在一起，一一对应</p>
</li>
<li><p>zipwithindex：RDD的值和各自的下标压缩在一起，形成K-V格式RDD。如：(a,0)</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">rdd1.zip(rdd2).foreach(println)</span><br><span class="line">val rdd = rdd1.zipWithIndex()</span><br><span class="line">rdd.foreach(println)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-1-16-其他"><a href="#9-1-16-其他" class="headerlink" title="9.1.16 其他"></a>9.1.16 其他</h4><ul>
<li><p>lookup()</p>
<p>查询指定的key, 返回其对应的value</p>
</li>
<li><p>top</p>
<p>返回最大的k个元素</p>
</li>
<li><p>saveAsTextFile</p>
<p>将数据输出，存储到 HDFS 的指定目录</p>
</li>
<li><p>cache </p>
<p>将 RDD 元素从磁盘缓存到内存</p>
<p>内部默认会调用persist(StorageLevel.MEMORY_ONLY)，也就是说它无法自定义缓存级别的。</p>
</li>
<li><p>persist()</p>
<p>与cache一样都是将一个RDD进行缓存，在之后的使用过程汇总不需要重新的计算了。它比cache灵活，可以通过自定义StorageLevel类型参数，来定义缓存的级别。</p>
</li>
</ul>
<p>###9.2 Action算子</p>
<h4 id="9-2-1-count"><a href="#9-2-1-count" class="headerlink" title="9.2.1 count"></a>9.2.1 count</h4><ul>
<li><p>计算数据的个数</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val linecount = lines.count()</span><br><span class="line">println(linecount)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-2-2-collect"><a href="#9-2-2-collect" class="headerlink" title="9.2.2 collect"></a>9.2.2 collect</h4><ul>
<li><p>回收计算结果到Driver端的内存</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val result = lines.collect().foreach(println)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-2-3-first"><a href="#9-2-3-first" class="headerlink" title="9.2.3 first"></a>9.2.3 first</h4><ul>
<li><p>取第一条数据。由take(1)实现</p>
</li>
<li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">val result = lines.first()</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-2-4-take"><a href="#9-2-4-take" class="headerlink" title="9.2.4 take"></a>9.2.4 take</h4><ul>
<li>取指定行的数据</li>
<li>val result = lines.take(5)</li>
<li>result.foreach(println)</li>
</ul>
<h4 id="9-2-5-foreachPartition"><a href="#9-2-5-foreachPartition" class="headerlink" title="9.2.5 foreachPartition"></a>9.2.5 foreachPartition</h4><ul>
<li><p>遍历每个partition上的数据</p>
</li>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rdd1.foreachPartition(iter=&gt;&#123;</span><br><span class="line">	println(<span class="string">"开始"</span>)</span><br><span class="line">	<span class="keyword">while</span> (iter.hasNext)&#123;</span><br><span class="line">		<span class="keyword">val</span> s = iter.next()</span><br><span class="line">		println(<span class="string">"插入："</span>+s)</span><br><span class="line">	&#125;</span><br><span class="line">	println(<span class="string">"结束"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="9-2-6-reduce-amp-countByKey-amp-countByValue"><a href="#9-2-6-reduce-amp-countByKey-amp-countByValue" class="headerlink" title="9.2.6 reduce&amp;countByKey&amp;countByValue"></a>9.2.6 reduce&amp;countByKey&amp;countByValue</h4><ul>
<li><p>reduce 聚合执行对应的逻辑</p>
</li>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> result = sc.parallelize(<span class="type">List</span>[<span class="type">Int</span>](<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)).reduce(_+_)</span><br><span class="line">println(result)</span><br></pre></td></tr></table></figure>
</li>
<li><p>countByKey 按照key分组，count每个key 对应value的个数</p>
</li>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize(<span class="type">List</span>[(<span class="type">String</span>,<span class="type">Int</span>)]((<span class="string">"a"</span>,<span class="number">100</span>),(<span class="string">"b"</span>,<span class="number">200</span>),(<span class="string">"a"</span>,<span class="number">300</span>),(<span class="string">"d"</span>,<span class="number">400</span>))).countByKey().foreach(println)</span><br></pre></td></tr></table></figure>
</li>
<li><p>countByValue: (key,value)整体 进行分组，计算出现次数。输出：((a,100),2)</p>
</li>
<li><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.parallelize(<span class="type">List</span>[(<span class="type">String</span>,<span class="type">Int</span>)]((<span class="string">"a"</span>,<span class="number">100</span>),(<span class="string">"b"</span>,<span class="number">200</span>),(<span class="string">"a"</span>,<span class="number">300</span>),(<span class="string">"a"</span>,<span class="number">100</span>),(<span class="string">"d"</span>,<span class="number">400</span>))).countByValue().foreach(println)</span><br></pre></td></tr></table></figure>
</li>
</ul>

    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          本文作者 : fenghuayangyi <br>
        
        原文链接 : <a href>https://github.com/fenghuayangyi/2019/10/16/scala笔记/</a><br>
        版权声明 : 本博客采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。
        </blockquote>
      </div>
    </div>
  
  
  

  
    <div id="reward">
  
    <p id="reward-meta">知识 & 情怀 | 二者兼得</p>
  
  <button id="reward-btn">
    
    <span>投食</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/wechat.png" alt="微信扫一扫, 向我投食">
        <p class="qrcode-meta">微信扫一扫, 向我投食</p>
      </div>
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/alipay.png" alt="支付宝扫一扫, 向我投食">
        <p class="qrcode-meta">支付宝扫一扫, 向我投食</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>标签: 
          
          <span class="span--tag">
            <a href="/tags/Scala/">
              #Scala
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>


  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        上一篇:
        <a href="/2019/10/15/spark笔记/" target="_self">Spark笔记</a>
      </div>
    
    
      <div class="nav-next">
        下一篇:
        <a href="/2019/10/18/HBase/" target="_self">HBase笔记</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

   

   

</div>


      <footer>
  <p class="site-info">
    博客已运行<span id="time-to-now"></span><span class="my-face">(●'◡'●)ﾉ♥</span>
    
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2018, 11, 10).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "天" + hour + "小时" + minute + "分钟" + second + "秒";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //关闭js加载过程信息
      messageStyle: "none", //不显示信息
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //行内公式选择符
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //段内公式选择符
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //避开某些标签
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //可选字体
        showMathMenu: false //关闭右击菜单显示
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
  </body>

</html>
